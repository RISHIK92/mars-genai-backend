"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.imageToImageMasking = exports.imageToImageUpscale = exports.imageToImage = exports.textToImage = void 0;
const axios_1 = __importDefault(require("axios"));
const fs_extra_1 = __importDefault(require("fs-extra"));
const os_1 = __importDefault(require("os"));
const path_1 = __importDefault(require("path"));
const uuid_1 = require("uuid");
const form_data_1 = __importDefault(require("form-data"));
const util_1 = require("../util");
const Util = __importStar(require("../util"));
const RESOURCE = 'generation';
var Endpoints;
(function (Endpoints) {
    Endpoints["TEXT_TO_IMAGE"] = "text-to-image";
    Endpoints["IMAGE_TO_IMAGE"] = "image-to-image";
    Endpoints["IMAGE_TO_IMAGE_UPSCALE"] = "image-to-image/upscale";
    Endpoints["IMAGE_TO_IMAGE_MASKING"] = "image-to-image/masking";
})(Endpoints || (Endpoints = {}));
async function processArtifacts(artifacts) {
    const results = [];
    for (const artifact of artifacts) {
        const finishReason = artifact.finish_reason;
        const filename = `${(0, uuid_1.v4)()}.png`;
        const filepath = path_1.default.join(os_1.default.tmpdir(), filename);
        await fs_extra_1.default.writeFile(filepath, artifact.base64, 'base64');
        results.push({
            filepath,
            content_filtered: finishReason === 'CONTENT_FILTERED',
            errored: finishReason === 'ERROR',
            seed: artifact.seed,
        });
    }
    return results;
}
/**
 * Stability AI Text To Image (v1)
 *
 * @param text_prompts - Text prompts to use for generating the image
 * @param options - Additional options for the generation
 */
async function textToImage(...args) {
    const [engineId, textPrompts, options] = args;
    const body = {
        text_prompts: textPrompts,
        ...(options || {}),
    };
    const response = await axios_1.default.post(Util.makeUrl(util_1.APIVersion.V1, RESOURCE, engineId + '/' + Endpoints.TEXT_TO_IMAGE), body, {
        headers: {
            ...this.orgAuthHeaders,
            Accept: 'application/json',
            'Content-Type': 'application/json',
        },
        validateStatus: undefined,
    });
    if (response.status === 200 && Array.isArray(response.data.artifacts)) {
        return processArtifacts(response.data.artifacts);
    }
    throw new util_1.StabilityAIError(response.status, 'Failed to run text to image', response.data);
}
exports.textToImage = textToImage;
/**
 * Stability AI Image To Image (v1)
 *
 */
async function imageToImage(...args) {
    const [engineId, textPrompts, initImage, options] = args;
    const imageFilepath = await Util.downloadImage(initImage);
    const formData = {
        init_image: fs_extra_1.default.createReadStream(imageFilepath),
        text_prompts: textPrompts,
        ...(options || {}),
    };
    const response = await axios_1.default.postForm(Util.makeUrl(util_1.APIVersion.V1, RESOURCE, engineId + '/' + Endpoints.IMAGE_TO_IMAGE), axios_1.default.toFormData(formData, new form_data_1.default()), {
        validateStatus: undefined,
        headers: {
            ...this.authHeaders,
            Accept: 'application/json',
        },
    });
    if (response.status === 200 && Array.isArray(response.data.artifacts)) {
        return processArtifacts(response.data.artifacts);
    }
    throw new util_1.StabilityAIError(response.status, 'Failed to run image to image', response.data);
}
exports.imageToImage = imageToImage;
/**
 * Stability AI Image To Image Upscale (v1)
 *
 */
async function imageToImageUpscale(...args) {
    const [image, options] = args;
    const imageFilepath = await Util.downloadImage(image);
    const { type, ...typeOptions } = options;
    const engineId = type === 'esrgan' ? 'esrgan-v1-x2plus' : 'stable-diffusion-x4-latent-upscaler';
    const formData = {
        image: fs_extra_1.default.createReadStream(imageFilepath),
        ...typeOptions,
    };
    const response = await axios_1.default.postForm(Util.makeUrl(util_1.APIVersion.V1, RESOURCE, engineId + '/' + Endpoints.IMAGE_TO_IMAGE_UPSCALE), axios_1.default.toFormData(formData, new form_data_1.default()), {
        validateStatus: undefined,
        headers: {
            ...this.authHeaders,
            Accept: 'application/json',
        },
    });
    if (response.status === 200 && Array.isArray(response.data.artifacts)) {
        return processArtifacts(response.data.artifacts);
    }
    throw new util_1.StabilityAIError(response.status, 'Failed to run image to image upscale', response.data);
}
exports.imageToImageUpscale = imageToImageUpscale;
/**
 * Stability AI Image To Image Upscale (v1)
 *
 */
async function imageToImageMasking(...args) {
    const [engineId, textPrompts, initImage, options] = args;
    const imageFilepath = await Util.downloadImage(initImage);
    let maskFilepath = undefined;
    let otherOptions;
    if ('mask_image' in options) {
        maskFilepath = await Util.downloadImage(options.mask_image);
        const { mask_image, ...other } = options;
        otherOptions = other;
    }
    else {
        const { ...other } = options;
        otherOptions = other;
    }
    const formData = {
        init_image: fs_extra_1.default.createReadStream(imageFilepath),
        text_prompts: textPrompts,
        ...otherOptions,
    };
    if (maskFilepath)
        formData.mask_image = fs_extra_1.default.createReadStream(maskFilepath);
    const response = await axios_1.default.postForm(Util.makeUrl(util_1.APIVersion.V1, RESOURCE, engineId + '/' + Endpoints.IMAGE_TO_IMAGE_MASKING), axios_1.default.toFormData(formData, new form_data_1.default()), {
        validateStatus: undefined,
        headers: {
            ...this.authHeaders,
            Accept: 'application/json',
        },
    });
    if (response.status === 200 && Array.isArray(response.data.artifacts)) {
        return processArtifacts(response.data.artifacts);
    }
    throw new util_1.StabilityAIError(response.status, 'Failed to run image to image masking', response.data);
}
exports.imageToImageMasking = imageToImageMasking;
//# sourceMappingURL=generation.js.map
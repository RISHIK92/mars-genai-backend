"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.imageToVideoResult = exports.imageToVideo = exports.inpaint = exports.upscaleResult = exports.upscale = void 0;
const axios_1 = __importDefault(require("axios"));
const fs_extra_1 = __importDefault(require("fs-extra"));
const os_1 = __importDefault(require("os"));
const path_1 = __importDefault(require("path"));
const uuid_1 = require("uuid");
const form_data_1 = __importDefault(require("form-data"));
const util_1 = require("../util");
const Util = __importStar(require("../util"));
const RESOURCE = 'generation';
var Endpoints;
(function (Endpoints) {
    Endpoints["STABLE_IMAGE_UPSCALE"] = "stable-image/upscale";
    Endpoints["STABLE_IMAGE_UPSCALE_RESULT"] = "stable-image/upscale/result";
    Endpoints["STABLE_IMAGE_INPAINT"] = "stable-image/inpaint";
    Endpoints["IMAGE_TO_VIDEO"] = "image-to-video";
    Endpoints["IMAGE_TO_VIDEO_RESULT"] = "image-to-video/result";
})(Endpoints || (Endpoints = {}));
/**
 * Stability AI Stable Image Upscale (v2Alpha)
 *
 * @param image - URL of the image to upscale
 * @param prompt - Prompt to use for upscaling
 * @param negative_prompt - Negative prompt to use for upscaling
 * @param output_format - Output format of the upscaled image
 * @param seed - Seed for the upscaling
 * @param creativity - Creativity for the upscaling (0-0.35)
 */
async function upscale(...args) {
    const [image, prompt, negativePrompt, outputFormat, seed, creativity] = args;
    const filepath = await Util.downloadImage(image);
    const formData = {
        image: fs_extra_1.default.createReadStream(filepath),
        prompt,
    };
    if (negativePrompt)
        formData.negative_prompt = negativePrompt;
    if (outputFormat)
        formData.output_format = outputFormat;
    if (seed)
        formData.seed = seed;
    if (creativity)
        formData.creativity = creativity;
    const response = await axios_1.default.postForm(Util.makeUrl(util_1.APIVersion.V2_ALPHA, RESOURCE, Endpoints.STABLE_IMAGE_UPSCALE), axios_1.default.toFormData(formData, new form_data_1.default()), {
        validateStatus: undefined,
        headers: this.authHeaders,
    });
    fs_extra_1.default.unlinkSync(filepath);
    if (response.status === 200 && typeof response.data.id === 'string') {
        return { id: response.data.id, output_format: outputFormat || 'png' };
    }
    throw new util_1.StabilityAIError(response.status, 'Failed to start upscale', response.data);
}
exports.upscale = upscale;
/**
 * Stability AI Stable Image Upscale Result (v2Alpha)
 *
 * @param id - ID of the upscale job
 * @param output_format - Output format requested in original upscale request
 * @returns
 */
async function upscaleResult(...args) {
    const [id, outputFormat] = args;
    const response = await axios_1.default.get(Util.makeUrl(util_1.APIVersion.V2_ALPHA, RESOURCE, Endpoints.STABLE_IMAGE_UPSCALE_RESULT) + `/${id}`, {
        validateStatus: undefined,
        headers: {
            ...this.authHeaders,
            Accept: 'application/json',
        },
    });
    if (response.status === 200) {
        const image = response.data.image;
        const finishReason = response.data.finish_reason;
        const filename = `${(0, uuid_1.v4)()}.${outputFormat || 'png'}`;
        const filepath = path_1.default.join(os_1.default.tmpdir(), filename);
        await fs_extra_1.default.writeFile(filepath, image, 'base64');
        return {
            filepath,
            content_filtered: finishReason === 'CONTENT_FILTERED',
            errored: false,
            seed: response.data.seed,
        };
    }
    else if (response.status === 202 &&
        typeof response.data.id === 'string' &&
        response.data.status === 'in-progress') {
        const { id, status } = response.data;
        return { id, status };
    }
    throw new util_1.StabilityAIError(response.status, 'Failed to fetch upscale result', response.data);
}
exports.upscaleResult = upscaleResult;
/**
 * Stability AI Stable Image Inpaint (v2Alpha)
 *
 * @param options - Inpaint Options
 */
async function inpaint(...args) {
    const [modeOptions, image, prompt, negativePrompt, seed, outputFormat] = args;
    const imageFilepath = await Util.downloadImage(image);
    const maskFilepath = modeOptions.mode === 'mask' && modeOptions.mask ? await Util.downloadImage(modeOptions.mask) : undefined;
    const formData = {
        mode: modeOptions.mode,
        image: fs_extra_1.default.createReadStream(imageFilepath),
        prompt,
    };
    if (negativePrompt)
        formData.negative_prompt = negativePrompt;
    if (seed)
        formData.seed = seed;
    if (outputFormat)
        formData.output_format = outputFormat;
    switch (modeOptions.mode) {
        case 'mask':
            if (maskFilepath)
                formData.mask = fs_extra_1.default.createReadStream(maskFilepath);
            break;
        case 'search':
            formData.search_prompt = modeOptions.search_prompt;
            break;
    }
    const response = await axios_1.default.postForm(Util.makeUrl(util_1.APIVersion.V2_ALPHA, RESOURCE, Endpoints.STABLE_IMAGE_INPAINT), axios_1.default.toFormData(formData, new form_data_1.default()), {
        validateStatus: undefined,
        headers: {
            ...this.authHeaders,
            Accept: 'application/json',
        },
    });
    fs_extra_1.default.unlinkSync(imageFilepath);
    if (maskFilepath)
        fs_extra_1.default.unlinkSync(maskFilepath);
    if (response.status === 200) {
        const image = response.data.image;
        const finishReason = response.data.finish_reason;
        const filename = `${(0, uuid_1.v4)()}.${outputFormat || 'png'}`;
        const filepath = path_1.default.join(os_1.default.tmpdir(), filename);
        await fs_extra_1.default.writeFile(filepath, image, 'base64');
        return {
            filepath,
            content_filtered: finishReason === 'CONTENT_FILTERED',
            errored: false,
            seed: response.data.seed,
        };
    }
    throw new util_1.StabilityAIError(response.status, 'Failed to run inpaint', response.data);
}
exports.inpaint = inpaint;
/**
 * Stability AI Image to Video (v2Alpha)
 *
 * @param options - Image to Video Options
 */
async function imageToVideo(...args) {
    const [image, seed, motionBucketId, cfgScale] = args;
    const imageFilepath = await Util.downloadImage(image);
    const formData = {
        image: fs_extra_1.default.createReadStream(imageFilepath),
    };
    if (seed)
        formData.seed = seed;
    if (motionBucketId)
        formData.motion_bucket_id = motionBucketId;
    if (cfgScale)
        formData.cfg_scale = cfgScale;
    const response = await axios_1.default.postForm(Util.makeUrl(util_1.APIVersion.V2_ALPHA, RESOURCE, Endpoints.IMAGE_TO_VIDEO), axios_1.default.toFormData(formData, new form_data_1.default()), {
        validateStatus: undefined,
        headers: {
            ...this.authHeaders,
            Accept: 'application/json',
        },
    });
    fs_extra_1.default.unlinkSync(imageFilepath);
    if (response.status === 200 && typeof response.data.id === 'string') {
        return { id: response.data.id };
    }
    throw new util_1.StabilityAIError(response.status, 'Failed to start image to video', response.data);
}
exports.imageToVideo = imageToVideo;
/**
 * Stability AI Stable Image To Video Result (v2Alpha)
 *
 * @param id - ID of the upscale job
 * @returns
 */
async function imageToVideoResult(...args) {
    const [id] = args;
    const response = await axios_1.default.get(Util.makeUrl(util_1.APIVersion.V2_ALPHA, RESOURCE, Endpoints.IMAGE_TO_VIDEO_RESULT) + `/${id}`, {
        validateStatus: undefined,
        headers: {
            ...this.authHeaders,
            Accept: 'application/json',
        },
    });
    if (response.status === 200) {
        const video = response.data.video;
        const finishReason = response.data.finish_reason;
        const filename = `${(0, uuid_1.v4)()}.mp4`;
        const filepath = path_1.default.join(os_1.default.tmpdir(), filename);
        await fs_extra_1.default.writeFile(filepath, video, 'base64');
        return {
            filepath,
            content_filtered: finishReason === 'CONTENT_FILTERED',
            errored: false,
            seed: response.data.seed,
        };
    }
    else if (response.status === 202 &&
        typeof response.data.id === 'string' &&
        response.data.status === 'in-progress') {
        const { id, status } = response.data;
        return { id, status };
    }
    throw new util_1.StabilityAIError(response.status, 'Failed to fetch image to video result', response.data);
}
exports.imageToVideoResult = imageToVideoResult;
//# sourceMappingURL=generation.js.map